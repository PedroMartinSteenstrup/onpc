/*
 * Enhanced Music Controller
 * Copyright (C) 2019-2022 by Mikhail Kulesh
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU
 * General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details. You should have received a copy of the GNU General
 * Public License along with this program.
 */
// @dart=2.9

import "dart:typed_data";
import "dart:ui";

import "package:flutter/material.dart";
import "package:flutter/src/painting/edge_insets.dart";
import "package:flutter/src/widgets/framework.dart";
import "package:flutter_libserialport/flutter_libserialport.dart";
import "package:flutter_markdown/flutter_markdown.dart";
import "package:flutter_markdown/src/style_sheet.dart";
import "package:url_launcher/url_launcher.dart";
import "package:window_manager/window_manager.dart";

import "../config/Configuration.dart";
import "Logging.dart";
import "Pair.dart";

class MyCustomScrollBehavior extends MaterialScrollBehavior
{
    // Override behavior methods and getters like dragDevices
    // See https://docs.flutter.dev/release/breaking-changes/default-scroll-behavior-drag
    @override
    Set<PointerDeviceKind> get dragDevices =>
    {
        PointerDeviceKind.touch,
        PointerDeviceKind.mouse,
        // etc.
    };
}

class SerialPortWrapper
{
    SerialPort _port;

    static List<Pair<String, String>> getPorts()
    {
        final List<Pair<String, String>> _ports = [];
        for (final String name in SerialPort.availablePorts)
        {
            final SerialPort sp = SerialPort(name);
            final Pair<String, String> port = Pair(name, sp.description);
            _ports.add(port);
            sp.dispose();
        }
        return _ports;
    }

    void openPort(String name)
    {
        if (name.isEmpty)
        {
            _port = null;
            return;
        }
        final SerialPort sp = SerialPort(name);
        if (sp.openReadWrite())
        {
            final SerialPortConfig cfg = SerialPortConfig();
            cfg.baudRate = 115200;
            cfg.bits = 8;
            cfg.parity = -1;
            cfg.stopBits = 1;
            cfg.rts = 0;
            cfg.cts = 0;
            cfg.dtr = 0;
            cfg.dsr = 0;
            cfg.xonXoff = 0;
            _port = sp;
            _port.config = cfg;
            Logging.info(this, "open serial port: " + _port.name);
        }
        else
        {
            Logging.info(this, "can not open serial port: " + SerialPort.lastError.toString());
            sp.dispose();
        }
    }

    void dispose()
    {
        if (_port != null)
        {
            Logging.info(this, "close serial port: " + _port.name);
            _port.close();
            _port.dispose();
            _port = null;
        }
    }

    void sendMessage(final String data)
    {
        if (_port == null || !_port.isOpen)
        {
            Logging.info(this, "can not send RI command: port not initialized");
            return;
        }
        if (data == null || data.isEmpty)
        {
            return;
        }
        try
        {
            final Uint8List bytes = Uint8List.fromList(data.codeUnits);
            final int res = _port.write(bytes);
            Logging.info(this, "sending " + data + bytes.toString()
                + " to " + _port.name + "; written " + res.toString() + " bytes");
            _port.drain();
        }
        on Exception
        {
            Logging.info(this, "can not write into serial port: " + SerialPort.lastError.toString());
        }
    }
}

class MarkdownWrapper
{
    static Widget buildMarkdown(String data, MarkdownStyleSheet styleSheet, EdgeInsetsGeometry padding)
    {
        return Markdown(data: data,
            styleSheet: styleSheet,
            padding: padding,
            onTapLink: (String text, String href, String title)
            {
                if (href != null)
                {
                    _launchURL(href);
                }
            });
    }

    static void _launchURL(final String url) async
    {
        if (await canLaunch(url))
        {
            await launch(url);
        }
    }
}

class WindowManagerWrapper with WindowListener
{
    final Configuration _configuration;

    WindowManagerWrapper(this._configuration);

    void restoreWindow() async
    {
        Logging.info(this, "Restore window size and position");
        await windowManager.ensureInitialized();
        await windowManager.waitUntilReadyToShow().then((_) async
        {
            await windowManager.setSize(_configuration.appSettings.windowSize());
            await windowManager.setPosition(_configuration.appSettings.windowOffset());
            await windowManager.show();
        });
    }

    void initState()
    {
        windowManager.addListener(this);
    }

    void dispose()
    {
        windowManager.removeListener(this);
    }

    @override
    void onWindowResize()
    {
        windowManager.getBounds().then((Rect rect)
        {
            _configuration.appSettings.windowFrame = rect;
        });
    }

    @override
    void onWindowMove()
    {
        windowManager.getBounds().then((Rect rect)
        {
            _configuration.appSettings.windowFrame = rect;
        });
    }
}